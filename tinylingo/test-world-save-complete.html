<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸–ç•Œä¿å­˜åŠŸèƒ½å®Œæ•´æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #FFFBF5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        .button:hover {
            background: #0056b3;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        .info { background: #d1ecf1; color: #0c5460; }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .form-group {
            margin: 10px 0;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .canvas-preview {
            border: 2px dashed #ccc;
            min-height: 200px;
            padding: 20px;
            text-align: center;
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ä¸–ç•Œä¿å­˜åŠŸèƒ½å®Œæ•´æµ‹è¯•</h1>
        
        <div class="section">
            <h2>æµ‹è¯•æ§åˆ¶é¢æ¿</h2>
            <button class="button" onclick="clearAllData()">æ¸…ç©ºæ‰€æœ‰æ•°æ®</button>
            <button class="button" onclick="checkCurrentState()">æ£€æŸ¥å½“å‰çŠ¶æ€</button>
            <button class="button" onclick="simulateWorldCreation()">æ¨¡æ‹Ÿåˆ›å»ºä¸–ç•Œ</button>
            <button class="button" onclick="testSaveFunction()">æµ‹è¯•ä¿å­˜åŠŸèƒ½</button>
            <button class="button" onclick="testSupabaseSync()">æµ‹è¯•SupabaseåŒæ­¥</button>
        </div>

        <div class="grid">
            <div class="section">
                <h2>åˆ›å»ºæ–°ä¸–ç•Œ</h2>
                <div class="form-group">
                    <label>ä¸–ç•Œåç§°:</label>
                    <input type="text" id="worldName" value="æµ‹è¯•ä¸–ç•Œ" />
                </div>
                <div class="form-group">
                    <label>ä¸–ç•Œæè¿°:</label>
                    <textarea id="worldDescription" rows="3">è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ä¸–ç•Œï¼Œç”¨äºéªŒè¯ä¿å­˜åŠŸèƒ½</textarea>
                </div>
                <div class="form-group">
                    <label>é€‰æ‹©èƒŒæ™¯:</label>
                    <select id="backgroundSelect">
                        <option value="">æ— èƒŒæ™¯</option>
                        <option value="kitchen">å¨æˆ¿</option>
                        <option value="garden">èŠ±å›­</option>
                        <option value="classroom">æ•™å®¤</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>æ·»åŠ è´´çº¸ (JSONæ ¼å¼):</label>
                    <textarea id="stickerData" rows="5" placeholder='{"word": "apple", "cn": "è‹¹æœ", "pos": "noun", ...}'></textarea>
                </div>
                <button class="button" onclick="createTestWorld()">åˆ›å»ºæµ‹è¯•ä¸–ç•Œ</button>
            </div>

            <div class="section">
                <h2>ç”»å¸ƒé¢„è§ˆ</h2>
                <div class="canvas-preview" id="canvasPreview">
                    <p>ç”»å¸ƒå†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>ä¿å­˜çŠ¶æ€</h2>
            <div id="saveStatus" class="status info">ç­‰å¾…æ“ä½œ...</div>
        </div>

        <div class="section">
            <h2>localStorage æ•°æ®</h2>
            <div id="localStorageData" class="log">ç­‰å¾…æ£€æŸ¥...</div>
        </div>

        <div class="section">
            <h2>æ“ä½œæ—¥å¿—</h2>
            <div id="operationLog" class="log">æ—¥å¿—å°†åœ¨è¿™é‡Œæ˜¾ç¤º...</div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿ WorldDataUtils ç±»
        class MockWorldDataUtils {
            static async addWorld(worldData) {
                log('ğŸ”„ è°ƒç”¨ addWorld æ–¹æ³•');
                log('ğŸ“ ä¸–ç•Œæ•°æ®:', JSON.stringify(worldData, null, 2));
                
                try {
                    // è·å–ç”¨æˆ·ID (æ¨¡æ‹Ÿ)
                    const userId = 'joyce'; // æ¨¡æ‹Ÿç”¨æˆ·ID
                    const storageKey = `tinylingo_worlds_${userId}`;
                    
                    // è·å–ç°æœ‰æ•°æ®
                    let existingWorlds = [];
                    const existingData = localStorage.getItem(storageKey);
                    if (existingData) {
                        existingWorlds = JSON.parse(existingData);
                        log('ğŸ“š ç°æœ‰ä¸–ç•Œæ•°é‡:', existingWorlds.length);
                    }
                    
                    // ç”Ÿæˆæ–°çš„ä¸–ç•ŒID
                    const newId = Date.now().toString();
                    worldData.id = newId;
                    worldData.createdAt = new Date().toISOString();
                    worldData.updatedAt = new Date().toISOString();
                    
                    // æ·»åŠ åˆ°æ•°ç»„
                    existingWorlds.push(worldData);
                    
                    // ä¿å­˜åˆ° localStorage
                    localStorage.setItem(storageKey, JSON.stringify(existingWorlds));
                    log('âœ… ä¸–ç•Œå·²ä¿å­˜åˆ° localStorage');
                    
                    // è§¦å‘å­˜å‚¨äº‹ä»¶
                    window.dispatchEvent(new StorageEvent('storage', {
                        key: storageKey,
                        newValue: JSON.stringify(existingWorlds),
                        oldValue: existingData
                    }));
                    
                    // æ¨¡æ‹Ÿ Supabase åŒæ­¥
                    await this.mockSupabaseSync(worldData);
                    
                    return { success: true, id: newId };
                } catch (error) {
                    log('âŒ ä¿å­˜å¤±è´¥:', error.message);
                    return { success: false, error: error.message };
                }
            }
            
            static async updateWorld(worldData) {
                log('ğŸ”„ è°ƒç”¨ updateWorld æ–¹æ³•');
                log('ğŸ“ æ›´æ–°æ•°æ®:', JSON.stringify(worldData, null, 2));
                
                try {
                    const userId = 'joyce';
                    const storageKey = `tinylingo_worlds_${userId}`;
                    
                    let existingWorlds = [];
                    const existingData = localStorage.getItem(storageKey);
                    if (existingData) {
                        existingWorlds = JSON.parse(existingData);
                    }
                    
                    // æŸ¥æ‰¾å¹¶æ›´æ–°
                    const index = existingWorlds.findIndex(w => w.id === worldData.id);
                    if (index !== -1) {
                        worldData.updatedAt = new Date().toISOString();
                        existingWorlds[index] = { ...existingWorlds[index], ...worldData };
                        
                        localStorage.setItem(storageKey, JSON.stringify(existingWorlds));
                        log('âœ… ä¸–ç•Œå·²æ›´æ–°');
                        
                        // æ¨¡æ‹Ÿ Supabase åŒæ­¥
                        await this.mockSupabaseSync(worldData);
                        
                        return { success: true };
                    } else {
                        log('âš ï¸ æœªæ‰¾åˆ°è¦æ›´æ–°çš„ä¸–ç•Œ');
                        return { success: false, error: 'ä¸–ç•Œä¸å­˜åœ¨' };
                    }
                } catch (error) {
                    log('âŒ æ›´æ–°å¤±è´¥:', error.message);
                    return { success: false, error: error.message };
                }
            }
            
            static async mockSupabaseSync(worldData) {
                log('ğŸ”„ æ¨¡æ‹Ÿ Supabase åŒæ­¥...');
                
                // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // æ¨¡æ‹ŸæˆåŠŸç‡ (90%)
                if (Math.random() > 0.1) {
                    log('âœ… Supabase åŒæ­¥æˆåŠŸ');
                    return { success: true };
                } else {
                    log('âŒ Supabase åŒæ­¥å¤±è´¥ (æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯)');
                    return { success: false, error: 'ç½‘ç»œé”™è¯¯' };
                }
            }
        }

        // æ—¥å¿—å‡½æ•°
        function log(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('operationLog');
            const logMessage = `[${timestamp}] ${message}`;
            
            if (data) {
                logElement.textContent += logMessage + '\n' + JSON.stringify(data, null, 2) + '\n\n';
            } else {
                logElement.textContent += logMessage + '\n';
            }
            
            logElement.scrollTop = logElement.scrollHeight;
            console.log(logMessage, data);
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('saveStatus');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        // æ¸…ç©ºæ‰€æœ‰æ•°æ®
        function clearAllData() {
            localStorage.clear();
            document.getElementById('operationLog').textContent = '';
            document.getElementById('localStorageData').textContent = '';
            updateStatus('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º', 'warning');
            log('ğŸ—‘ï¸ æ‰€æœ‰æ•°æ®å·²æ¸…ç©º');
        }

        // æ£€æŸ¥å½“å‰çŠ¶æ€
        function checkCurrentState() {
            log('ğŸ” æ£€æŸ¥å½“å‰çŠ¶æ€...');
            
            const userId = 'joyce';
            const storageKey = `tinylingo_worlds_${userId}`;
            const worldsData = localStorage.getItem(storageKey);
            
            const localStorageElement = document.getElementById('localStorageData');
            
            if (worldsData) {
                try {
                    const worlds = JSON.parse(worldsData);
                    localStorageElement.textContent = JSON.stringify(worlds, null, 2);
                    updateStatus(`æ‰¾åˆ° ${worlds.length} ä¸ªä¸–ç•Œ`, 'success');
                    log(`ğŸ“Š å½“å‰æœ‰ ${worlds.length} ä¸ªä¸–ç•Œ`);
                } catch (error) {
                    localStorageElement.textContent = 'æ•°æ®è§£æé”™è¯¯: ' + error.message;
                    updateStatus('æ•°æ®è§£æé”™è¯¯', 'error');
                    log('âŒ æ•°æ®è§£æé”™è¯¯:', error.message);
                }
            } else {
                localStorageElement.textContent = 'æ²¡æœ‰æ‰¾åˆ°ä¸–ç•Œæ•°æ®';
                updateStatus('æ²¡æœ‰ä¸–ç•Œæ•°æ®', 'info');
                log('ğŸ“­ æ²¡æœ‰æ‰¾åˆ°ä¸–ç•Œæ•°æ®');
            }
        }

        // æ¨¡æ‹Ÿä¸–ç•Œåˆ›å»º
        function simulateWorldCreation() {
            log('ğŸ® å¼€å§‹æ¨¡æ‹Ÿä¸–ç•Œåˆ›å»º...');
            
            const testWorld = {
                name: 'æ¨¡æ‹Ÿæµ‹è¯•ä¸–ç•Œ',
                description: 'è¿™æ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿåˆ›å»ºçš„æµ‹è¯•ä¸–ç•Œ',
                selectedBackground: 'kitchen',
                canvasObjects: [
                    {
                        type: 'sticker',
                        word: 'apple',
                        cn: 'è‹¹æœ',
                        pos: 'noun',
                        x: 100,
                        y: 100,
                        width: 80,
                        height: 80
                    },
                    {
                        type: 'sticker',
                        word: 'banana',
                        cn: 'é¦™è•‰',
                        pos: 'noun',
                        x: 200,
                        y: 150,
                        width: 80,
                        height: 80
                    }
                ],
                stickerCount: 2,
                uniqueWordCount: 2,
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                needsSupabaseSync: true
            };
            
            updateCanvasPreview(testWorld);
            updateStatus('æ¨¡æ‹Ÿä¸–ç•Œå·²åˆ›å»ºï¼Œå‡†å¤‡ä¿å­˜...', 'info');
            
            // è‡ªåŠ¨ä¿å­˜
            setTimeout(() => {
                MockWorldDataUtils.addWorld(testWorld).then(result => {
                    if (result.success) {
                        updateStatus('æ¨¡æ‹Ÿä¸–ç•Œä¿å­˜æˆåŠŸ!', 'success');
                        checkCurrentState();
                    } else {
                        updateStatus('æ¨¡æ‹Ÿä¸–ç•Œä¿å­˜å¤±è´¥: ' + result.error, 'error');
                    }
                });
            }, 1000);
        }

        // åˆ›å»ºæµ‹è¯•ä¸–ç•Œ
        function createTestWorld() {
            log('ğŸ—ï¸ åˆ›å»ºç”¨æˆ·å®šä¹‰çš„æµ‹è¯•ä¸–ç•Œ...');
            
            const name = document.getElementById('worldName').value;
            const description = document.getElementById('worldDescription').value;
            const background = document.getElementById('backgroundSelect').value;
            const stickerDataText = document.getElementById('stickerData').value;
            
            let stickerData = null;
            if (stickerDataText.trim()) {
                try {
                    stickerData = JSON.parse(stickerDataText);
                } catch (error) {
                    updateStatus('è´´çº¸æ•°æ®æ ¼å¼é”™è¯¯: ' + error.message, 'error');
                    log('âŒ è´´çº¸æ•°æ®è§£æå¤±è´¥:', error.message);
                    return;
                }
            }
            
            const testWorld = {
                name: name || 'æœªå‘½åä¸–ç•Œ',
                description: description || 'æ— æè¿°',
                selectedBackground: background,
                canvasObjects: [],
                stickerCount: 0,
                uniqueWordCount: 0,
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                needsSupabaseSync: true
            };
            
            // æ·»åŠ è´´çº¸åˆ°ç”»å¸ƒ
            if (stickerData) {
                testWorld.canvasObjects.push({
                    type: 'sticker',
                    ...stickerData,
                    x: 100,
                    y: 100,
                    width: 80,
                    height: 80
                });
                testWorld.stickerCount = 1;
                testWorld.uniqueWordCount = 1;
            }
            
            updateCanvasPreview(testWorld);
            updateStatus('æµ‹è¯•ä¸–ç•Œå·²åˆ›å»ºï¼Œæ­£åœ¨ä¿å­˜...', 'info');
            
            MockWorldDataUtils.addWorld(testWorld).then(result => {
                if (result.success) {
                    updateStatus('æµ‹è¯•ä¸–ç•Œä¿å­˜æˆåŠŸ!', 'success');
                    checkCurrentState();
                } else {
                    updateStatus('æµ‹è¯•ä¸–ç•Œä¿å­˜å¤±è´¥: ' + result.error, 'error');
                }
            });
        }

        // æ›´æ–°ç”»å¸ƒé¢„è§ˆ
        function updateCanvasPreview(worldData) {
            const preview = document.getElementById('canvasPreview');
            let content = `<h3>${worldData.name}</h3>`;
            content += `<p>${worldData.description}</p>`;
            
            if (worldData.selectedBackground) {
                content += `<p><strong>èƒŒæ™¯:</strong> ${worldData.selectedBackground}</p>`;
            }
            
            if (worldData.canvasObjects && worldData.canvasObjects.length > 0) {
                content += `<p><strong>å¯¹è±¡æ•°é‡:</strong> ${worldData.canvasObjects.length}</p>`;
                content += '<div style="text-align: left;">';
                worldData.canvasObjects.forEach((obj, index) => {
                    if (obj.type === 'sticker') {
                        content += `<p>è´´çº¸ ${index + 1}: ${obj.word} (${obj.cn})</p>`;
                    }
                });
                content += '</div>';
            }
            
            preview.innerHTML = content;
        }

        // æµ‹è¯•ä¿å­˜åŠŸèƒ½
        function testSaveFunction() {
            log('ğŸ§ª æµ‹è¯•ä¿å­˜åŠŸèƒ½...');
            
            const testCases = [
                {
                    name: 'åŸºç¡€ä¸–ç•Œ',
                    data: {
                        name: 'åŸºç¡€æµ‹è¯•',
                        description: 'åŸºç¡€åŠŸèƒ½æµ‹è¯•',
                        canvasObjects: [],
                        stickerCount: 0,
                        uniqueWordCount: 0
                    }
                },
                {
                    name: 'å¸¦èƒŒæ™¯çš„ä¸–ç•Œ',
                    data: {
                        name: 'èƒŒæ™¯æµ‹è¯•',
                        description: 'èƒŒæ™¯åŠŸèƒ½æµ‹è¯•',
                        selectedBackground: 'garden',
                        canvasObjects: [],
                        stickerCount: 0,
                        uniqueWordCount: 0
                    }
                },
                {
                    name: 'å¸¦è´´çº¸çš„ä¸–ç•Œ',
                    data: {
                        name: 'è´´çº¸æµ‹è¯•',
                        description: 'è´´çº¸åŠŸèƒ½æµ‹è¯•',
                        canvasObjects: [
                            {
                                type: 'sticker',
                                word: 'test',
                                cn: 'æµ‹è¯•',
                                pos: 'noun',
                                x: 50,
                                y: 50
                            }
                        ],
                        stickerCount: 1,
                        uniqueWordCount: 1
                    }
                }
            ];
            
            let successCount = 0;
            let totalTests = testCases.length;
            
            async function runTests() {
                for (let i = 0; i < testCases.length; i++) {
                    const testCase = testCases[i];
                    log(`ğŸ§ª æµ‹è¯•æ¡ˆä¾‹ ${i + 1}: ${testCase.name}`);
                    
                    try {
                        const result = await MockWorldDataUtils.addWorld(testCase.data);
                        if (result.success) {
                            log(`âœ… æµ‹è¯•æ¡ˆä¾‹ ${i + 1} æˆåŠŸ`);
                            successCount++;
                        } else {
                            log(`âŒ æµ‹è¯•æ¡ˆä¾‹ ${i + 1} å¤±è´¥: ${result.error}`);
                        }
                    } catch (error) {
                        log(`âŒ æµ‹è¯•æ¡ˆä¾‹ ${i + 1} å¼‚å¸¸: ${error.message}`);
                    }
                    
                    // çŸ­æš‚å»¶è¿Ÿ
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                const successRate = (successCount / totalTests * 100).toFixed(1);
                updateStatus(`æµ‹è¯•å®Œæˆ: ${successCount}/${totalTests} æˆåŠŸ (${successRate}%)`, 
                    successCount === totalTests ? 'success' : 'warning');
                
                checkCurrentState();
            }
            
            runTests();
        }

        // æµ‹è¯• Supabase åŒæ­¥
        function testSupabaseSync() {
            log('â˜ï¸ æµ‹è¯• Supabase åŒæ­¥åŠŸèƒ½...');
            
            const testWorld = {
                name: 'Supabase åŒæ­¥æµ‹è¯•',
                description: 'æµ‹è¯• Supabase åŒæ­¥åŠŸèƒ½',
                canvasObjects: [],
                stickerCount: 0,
                uniqueWordCount: 0,
                needsSupabaseSync: true
            };
            
            MockWorldDataUtils.mockSupabaseSync(testWorld).then(result => {
                if (result.success) {
                    updateStatus('Supabase åŒæ­¥æµ‹è¯•æˆåŠŸ', 'success');
                } else {
                    updateStatus('Supabase åŒæ­¥æµ‹è¯•å¤±è´¥: ' + result.error, 'error');
                }
            });
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥çŠ¶æ€
        window.addEventListener('load', () => {
            log('ğŸ“± é¡µé¢å·²åŠ è½½ï¼Œå¼€å§‹åˆå§‹åŒ–...');
            checkCurrentState();
        });

        // ç›‘å¬å­˜å‚¨å˜åŒ–
        window.addEventListener('storage', (e) => {
            if (e.key && e.key.startsWith('tinylingo_worlds_')) {
                log('ğŸ“¡ æ£€æµ‹åˆ°å­˜å‚¨å˜åŒ–:', e.key);
                checkCurrentState();
            }
        });
    </script>
</body>
</html>